/*
 * Copyright (C) 2019 Freie Universit√§t Berlin
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @{
 *
 * @file
 * @author  Martine Lenders <m.lenders@fu-berlin.de>
 */

#include <errno.h>
#include <stdint.h>

#ifdef MODULE_GNRC_IPV6_NIB
#include "net/gnrc/ipv6/nib.h"
#endif  /* MODULE_GNRC_IPV6_NIB */
#include "net/gnrc/netif/hdr.h"
#include "net/gnrc/nettype.h"
#include "net/gnrc/pktbuf.h"
#include "net/gnrc/sixlowpan/internal.h"
#ifdef MODULE_GNRC_SIXLOWPAN_IPHC
#include "net/gnrc/sixlowpan/iphc.h"
#endif  /* MODULE_GNRC_SIXLOWPAN_IPHC */
#include "utlist.h"

#include "net/gnrc/sixlowpan/frag/minfwd.h"

#define ENABLE_DEBUG    (0)
#include "debug.h"

gnrc_sixlowpan_frag_vrb_t *gnrc_sixlowpan_frag_minfwd_vrbe_from_route(
        const void *hdr, size_t hdr_len, gnrc_nettype_t hdr_type,
        gnrc_netif_t *netif, const gnrc_sixlowpan_rbuf_base_t *base)
{
    gnrc_sixlowpan_frag_vrb_t *res = NULL;

#ifdef NDEBUG
    (void)hdr_len;
#endif
    assert((hdr != NULL) && (hdr_len > 0));
    assert(base != NULL);
    switch (hdr_type) {
#ifdef MODULE_GNRC_IPV6_NIB
        case GNRC_NETTYPE_IPV6: {
            assert(hdr_len >= sizeof(ipv6_hdr_t));
            ipv6_addr_t *addr = &((ipv6_hdr_t *)hdr)->dst;
            gnrc_ipv6_nib_nc_t nce;

            if (!ipv6_addr_is_link_local(addr) &&
                (gnrc_netif_get_by_ipv6_addr(addr) == NULL) &&
                (gnrc_ipv6_nib_get_next_hop_l2addr(addr, netif, NULL,
                                                   &nce) == 0)) {
                res = gnrc_sixlowpan_frag_vrb_add(
                        base,
                        gnrc_netif_get_by_pid(gnrc_ipv6_nib_nc_get_iface(&nce)),
                        nce.l2addr, nce.l2addr_len
                    );
            }
            else {
                DEBUG("6lo minfwd: no FIB entry found\n");
            }
            break;
        }
#endif  /* MODULE_GNRC_IPV6_NIB */
        default:
            DEBUG("6lo minfwd: unknown hdr_type %d\n", hdr_type);
            break;
    }
    return res;
}

static gnrc_pktsnip_t *_netif_hdr_from_vrbe(gnrc_sixlowpan_frag_vrb_t *vrbe,
                                            gnrc_pktsnip_t *orig)
{
    gnrc_pktsnip_t *res;
    gnrc_netif_hdr_t *netif_hdr;

    res = gnrc_netif_hdr_build(NULL, 0, vrbe->out_dst, vrbe->out_dst_len);
    if (res == NULL) {
        DEBUG("6lo minfwd: can't allocate netif header for forwarding.\n");
        return NULL;
    }
    netif_hdr = res->data;
    gnrc_netif_hdr_set_netif(netif_hdr, vrbe->out_netif);
    if (orig->next != NULL) {
        gnrc_netif_hdr_t *old_netif_hdr = orig->next->data;

        netif_hdr->flags |= (old_netif_hdr->flags &
                             GNRC_NETIF_HDR_FLAGS_MORE_DATA);
        gnrc_pktbuf_remove_snip(orig, orig->next);
    }
    return res;
}

static int _forward_fragment(gnrc_sixlowpan_frag_vrb_t *vrbe,
                             gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *netif_hdr,
                             unsigned page)
{
    sixlowpan_frag_n_t *frag;
    frag = pkt->data;
#ifdef MODULE_GNRC_IPV6
    /* if is uncompressed IPv6 packet */
    if (((frag->disp_size.u8[0] & SIXLOWPAN_FRAG_DISP_MASK) ==
         SIXLOWPAN_FRAG_1_DISP) &&
        /* uncompressed dispatch is at position of offset for FRAG1 */
        (frag->offset == SIXLOWPAN_UNCOMP)) {
        ipv6_hdr_t *hdr = (ipv6_hdr_t *)(frag + 1);
        if (hdr->hl <= 1U) {
            DEBUG("6lo minfwd: minimal hop-limit reached\n");
            /* try to hand to IPv6 module */
            return -ETIMEDOUT;
        }
        /* decrement hop-limit */
        hdr->hl--;
    }
#endif  /* MODULE_GNRC_IPV6 */
    frag->tag = byteorder_htons(vrbe->out_tag);
    LL_PREPEND(pkt, netif_hdr);
    gnrc_sixlowpan_dispatch_send(pkt, NULL, page);
    return 0;
}

#ifdef MODULE_GNRC_SIXLOWPAN_IPHC
static gnrc_pktsnip_t *_mark_ipv6_hdr(gnrc_pktsnip_t *pkt)
{
    if (pkt->size > sizeof(ipv6_hdr_t)) {
        /* mark IPv6 header because that is what iphc_send expects */
        pkt->type = GNRC_NETTYPE_UNDEF;
        /* we don't need the header actually so we don't need a pointer
         * to store it in */
        if (gnrc_pktbuf_mark(pkt, sizeof(ipv6_hdr_t),
                             GNRC_NETTYPE_IPV6) == NULL) {
            return NULL;
        }
        /* gnrc_pktbuf_mark() returns packet in receive order so reverse
         * it;
         * XXX: since all snips in pkt are already write protected or
         * generated by within this function we can't fail with
         * gnrc_pktbuf_reverse_snips() */
        pkt = gnrc_pktbuf_reverse_snips(pkt);
    }
    return pkt;
}

static int _forward_iphc(gnrc_sixlowpan_frag_vrb_t *vrbe,
                         gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *netif_hdr,
                         unsigned page)
{
    gnrc_sixlowpan_msg_frag_t *frag_msg = gnrc_sixlowpan_msg_frag_get();
    ipv6_hdr_t *hdr = pkt->data;

    if (frag_msg == NULL) {
        return -ENOENT;
    }
    if (hdr->hl <= 1U) {
        DEBUG("6lo minfwd: minimal hop-limit reached\n");
        /* try to hand to IPv6 module */
        return -ETIMEDOUT;
    }
    /* decrement hop-limit */
    hdr->hl--;
    if ((pkt = _mark_ipv6_hdr(pkt)) == NULL) {
        return -ENOMEM;
    }
    LL_PREPEND(pkt, netif_hdr);
    frag_msg->datagram_size = vrbe->super.datagram_size;
    frag_msg->tag = vrbe->out_tag;
    /* Sending the first fragment has an offset==0 */
    frag_msg->offset = 0;
    gnrc_sixlowpan_iphc_send(pkt, frag_msg, page);
    return 0;
}
#endif  /* MODULE_GNRC_SIXLOWPAN_IPHC */

int gnrc_sixlowpan_frag_minfwd_forward(gnrc_sixlowpan_frag_vrb_t *vrbe,
                                       gnrc_pktsnip_t *pkt, size_t frag_size,
                                       unsigned page)
{
    gnrc_pktsnip_t *tmp;
    int res = 0;
    bool release_dup;

    assert(vrbe != NULL);
    assert(pkt != NULL);
    assert((pkt->next == NULL) || (pkt->next->type == GNRC_NETTYPE_NETIF));
    if ((tmp = gnrc_pktbuf_start_write(pkt)) == NULL) {
        DEBUG("6lo minfwd: can't write-protect fragment for forwarding.\n");
        gnrc_pktbuf_release(pkt);
        return -ENOMEM;
    }
    release_dup = (tmp != pkt);
    pkt = tmp;
    tmp = _netif_hdr_from_vrbe(vrbe, pkt);
    if (tmp == NULL) {
        gnrc_pktbuf_release(pkt);
        return -ENOMEM;
    }
    vrbe->super.current_size += (uint16_t)frag_size;
    switch (pkt->type) {
        case GNRC_NETTYPE_SIXLOWPAN:
            res = _forward_fragment(vrbe, pkt, tmp, page);
            if (res < 0) {
                goto error_return;
            }
            break;
#ifdef MODULE_GNRC_SIXLOWPAN_IPHC
        case GNRC_NETTYPE_IPV6:
            res = _forward_iphc(vrbe, pkt, tmp, page);
            if (res < 0) {
                goto error_return;
            }
            break;
#endif  /* MODULE_GNRC_SIXLOWPAN_IPHC */
        default:
            DEBUG("6lo minfwd: Unknown pkt->type %d\n", pkt->type);
            res = -EINVAL;
            goto error_return;
    }
    if (vrbe->super.current_size >= vrbe->super.datagram_size) {
        DEBUG("6lo minfwd: current_size (%u) >= datagram_size (%u)\n",
              vrbe->super.current_size, vrbe->super.datagram_size);
        gnrc_sixlowpan_frag_vrb_rm(vrbe);
    }
    return res;
error_return:
    gnrc_pktbuf_release(tmp);
    if (release_dup || (res == -ENOMEM)) {
        gnrc_pktbuf_release(pkt);
    }
    return res;
}

/** @} */
